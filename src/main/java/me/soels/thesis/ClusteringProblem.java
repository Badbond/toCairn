package me.soels.thesis;

import org.moeaframework.core.Solution;
import org.moeaframework.core.variable.EncodingUtils;
import org.moeaframework.problem.AbstractProblem;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Optional;

import static me.soels.thesis.EncodingType.ENCODING_TYPE_ATTRIBUTE_KEY;

public class ClusteringProblem extends AbstractProblem {
    private final List<Objective> objectives;
    private final ApplicationInput applicationInput;
    private final EncodingType encodingType;

    /**
     * Constructs a new instance of the clustering problem
     *
     * @param objectives       the objective functions to evaluate
     * @param applicationInput the input to cluster
     * @param encodingType     the type of solution encoding to use
     */
    public ClusteringProblem(List<Objective> objectives, ApplicationInput applicationInput, EncodingType encodingType) {
        super(applicationInput.getClasses().size(), objectives.size());
        this.objectives = objectives;
        this.applicationInput = applicationInput;
        this.encodingType = encodingType;
    }

    @Override
    public void evaluate(Solution solution) {
        var decodedClustering = decodeToClusters(solution);

        for (int i = 0; i < objectives.size(); i++) {
            solution.setObjective(i, objectives.get(i).calculate(decodedClustering, applicationInput));
        }
        // TODO: We normalized the clustering so that we could maybe filter out redundant duplicates (see JavaDoc).
        //  How can we do that during selection?
    }


    /**
     * Decodes the genes in the solution to the clusters identified.
     * <p>
     * The resulting clusters are also normalized in order of the {@link #applicationInput} nodes with increasing
     * incremental numbers starting from 0. This is to also make deduplication of redundant solutions possible. For
     * example, both A3-B2-C3 and A9-B3-C9 will map to A0-B1-C0 (in case of cluster-label encoding).
     *
     * @param solution the clustering generated by the evolutionary algorithm
     * @return the decoded and normalized clustering
     */
    private Clustering decodeToClusters(Solution solution) {
        var variables = EncodingUtils.getInt(solution);

        switch (encodingType) {
            case CLUSTER_LABEL:
                return decodeClusterLabelEncoding(variables);
            case GRAPH_ADJECENCY:
                return decodeGraphAdjacencyEncoding(variables);
            default:
                throw new IllegalStateException("Unsupported encoding type: " + encodingType);
        }
    }

    private Clustering decodeClusterLabelEncoding(int[] variables) {
        var clusterNormalizationMapping = new LinkedHashMap<Integer, Integer>();
        var result = new Clustering();
        for (int i = 0; i < variables.length; i++) {
            var clusterNumber = variables[i];
            clusterNormalizationMapping.putIfAbsent(clusterNumber, clusterNormalizationMapping.size());
            result.addToCluster(clusterNormalizationMapping.get(clusterNumber), applicationInput.getClasses().get(i));
        }
        return result;
    }

    private Clustering decodeGraphAdjacencyEncoding(int[] variables) {
        var nodeIndexClusterPair = new LinkedHashMap<Integer, Integer>();
        var result = new Clustering();
        int clusterCount = 0;
        for (int i = 0; i < variables.length; i++) {
            var linkedNode = variables[i];
            var existingCurrent = Optional.ofNullable(nodeIndexClusterPair.get(i));
            var existingLinked = Optional.ofNullable(nodeIndexClusterPair.get(linkedNode));

            // TODO: Simplify branches as suggested, but do document the condition as it is important for understanding.
            if (existingCurrent.isPresent() && existingLinked.isEmpty()) {
                // We have not yet seen the linked node, but for the current node a cluster was already created.
                // Add linked node to existing cluster
                nodeIndexClusterPair.put(linkedNode, existingCurrent.get());
            } else if (existingCurrent.isEmpty() && existingLinked.isPresent()) {
                // We have not yet seen the current node, but for the linked node a cluster was already created.
                // Add current node to existing cluster
                nodeIndexClusterPair.put(i, existingLinked.get());
            } else if (existingCurrent.isEmpty() && existingLinked.isEmpty()) {
                // We have not seen either node, create a new cluster for both
                nodeIndexClusterPair.put(i, clusterCount);
                nodeIndexClusterPair.put(linkedNode, clusterCount);
                clusterCount++;
            } else if (existingCurrent.isPresent() && existingLinked.isPresent() && !existingCurrent.get().equals(existingLinked.get())) {
                // TODO: Merge clusters :-(
                // TODO: Maybe we can order by value instead of key! That way, the directions is always in increasing order and perhaps we don't need to catch this case?
                throw new IllegalStateException("Not supported");
            } else {
                // TODO: Check if this a reachable branch or not. It should not...
                throw new IllegalStateException("Don't know what to do here. Please investigate");
            }
        }
        return result;
    }

    /**
     * Constructs the solution structure.
     * <p>
     * This does not do initialization of the initial population as that is depending on the algorithm. This therefore
     * only defines the structure of encoding used. Both cluster-label encoding and locus-adjacency graph encoding
     * have the same typing in terms of variables. They furthermore have the same bounds as well where in cluster-label
     * encoding there can be 1 up to n number of clusters and in locus-adjacency graph encoding every class can be
     * linked to any of the n classes, where n is the amount of classes.
     *
     * @return the solution structure
     */
    @Override
    public Solution newSolution() {
        // TODO: Investigate what FutureSolution does and whether it improves performance
        var solution = new Solution(getNumberOfVariables(), getNumberOfObjectives());
        solution.setAttribute(ENCODING_TYPE_ATTRIBUTE_KEY, encodingType);

        for (int i = 0; i < getNumberOfVariables(); i++) {
            solution.setVariable(i, EncodingUtils.newInt(0, getNumberOfVariables()));
        }
        return solution;
    }
}
